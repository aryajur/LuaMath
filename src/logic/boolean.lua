-- Module to process boolean expressions and truth tables

local modname = ...
local numT = require("num.transform")
local string = string
local tostring = tostring
local load = load
local pcall = pcall

local M = {}
package.loaded[modname] = M
if setfenv then
	setfenv(1,M)
else
	_ENV = M
end

-- Function to return expressions for all binary outputs given the number of input bits
-- bits = number of bits the truth table is made for
-- outT is a list of numbers signifying all output bits represented as numbers combined
-- Example:
--[[
    bits = 2
    outT = {3,4,12,15}  -- Note #outT=2^bits
    So here we are solving the truth table:
    I1    I0    O3   O2   O1   O0
     0     0     0    0    1    1
     0     1     0    1    0    0 
     1     0     1    1    0    0
     1     1     1    1    1    1
     
    Result returned will be:
    {
        -- For O0
        {"~I0.~I1+I0.I1", "I0.~I1+~I0.I1"}, -- 2nd one is the negated expression
        -- For O1
        {"~I0.~I1+I0.I1", "I0.~I1+~I0.I1"},
        -- For O2
        {"I0.~I1+~I0.I1+I0.I1", "~I0.~I1"},
        -- For O3
        {"~I0.I1+I0.I1", "~I0.~I1+I0.~I1"}
    }
    -- Note output array length = number of maximum bits in any number in the outT list
]]
function solveTruthTable(bits,outT)
    if not outT or #outT~=2^bits then
        return nil,"2nd argument needs to be a list of numbers 2^(1st argument) long."
    end
    -- Find the number of bits in the output
    local outB = 0
    local bin = {}
    for i = 1,#outT do
        bin[i] = numT.toBinary(outT[i])
        if #bin[i] > outB then
            outB = #bin[i]
        end
    end
    -- Make all the output binaries same length
    for i = 1,#outT do
        bin[i] = string.rep("0",outB-#bin[i])..bin[i]
    end

    local out = {}
    -- Now create the list of output expressions
    for i = 1,outB do
        -- Expressions for i th output bit
        out[i] = {"",""}
        for j = 1,#bin do
            -- Generate the logic expression for j
            local jbin = numT.toBinary(j-1)
            jbin = string.rep("0",bits-#jbin)..jbin
            local exp = ""
            for k = #jbin,1,-1 do
                exp = exp..(exp~="" and "." or "")..(jbin:sub(k,k)=="0" and "~I" or "I")..tostring(#jbin-k)
            end
            
            if bin[j]:sub(-1*i,-1*i) == "1" then
                -- This input generates a 1
                out[i][1] = out[i][1]..(out[i][1]~="" and "+" or "")..exp
            else
                -- This input generates a 0
                 out[i][2] = out[i][2]..(out[i][2]~="" and "+" or "")..exp
            end
        end
    end
    return out
end

-- Function to generate a truth table with the given expression. 
-- Expression should be as generated by the solveTruthTable function above
-- i is the number of variables
function getTruthTable(expr,i)
	expr = expr:gsub("i","I")
	local strtStr = ""		-- To store the boolean values for the variables q0 q1 etc.
	for j = 0,i-1 do
		strtStr = strtStr.."I"..tostring(j).."=false\n"
	end
	-- convert expression to Lua compatible syntax
	expr = expr:gsub("%~","not "):gsub("%+"," or "):gsub("%."," and ")
	-- Try evaluating it
	local safeenv = {}
	local f,msg = load(strtStr.."return "..expr,nil,"t",safeenv)
	if not f then
		return nil,"Cannot load the expression ->"..msg
	end
	local err
	err,msg = pcall(f)
	if not err then
		return nil,"Cannot evaluate the expression for all false values ->"..msg
	end
	-- Evaluate the truth table here
	local tt = ""	-- String to contain the truth table
	
	for j = 0,i-1 do
		tt = tt.."I"..tostring(i-1-j).." "
	end
	tt = tt.."out\n"
	local n
	local out = {}
	for j = 0,2^i-1 do
		local str = numT.toBinary(j,"0 ","1 ")
		str = string.rep("0 ",(2*i-#str)/2)..str
		tt = tt..str
		strtStr = ""
		for k = 0,i-1 do
			if str:sub(k*2+1,k*2+1)=="1" then
				strtStr = strtStr.."I"..tostring(i-1-k).."=true\n"
			else
				strtStr = strtStr.."I"..tostring(i-1-k).."=false\n"
			end
		end
		f,msg = load(strtStr.."return "..expr,nil,"t",safeenv)
		if not f then
			return nil,"Cannot load the expression ->"..msg
		end
		err,msg = pcall(f)
		if not err then
			return nil,"Cannot evaluate the expression for "..str.." values ->"..msg
		end
		if msg then
			tt = tt.."1\n"
			out[#out + 1] = 1
		else
			tt = tt.."0\n"
			out[#out + 1] = 0
		end
	end		--for j = 0,2^i-1 do ends
	return out,tt
end
